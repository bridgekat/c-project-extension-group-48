// Enhanced syntax!

(define patterns `(

  (_ (_ 0) (star (char " \f\n\r\t\v")))
  (_ (_ 0) (concat (word "//") (star (except "\n\r"))))
  (_ (_ 0)
    (concat (word "/*")
            (star (concat (star (except "*"))
                          (plus (char "*"))
                          (except "/")))
            (star (except "*"))
            (plus (char "*"))
            (char "/")))

  (symbol' (symbol 0)
    (concat (alt (range 97 122) (range 65 90) (char "_'") (utf8seg))
            (star (alt (range 97 122) (range 65 90) (range 48 57) (char "_'") (utf8seg)))))

  (nat64' (nat64 0)
    (alt (plus (range 48 57))
        (concat (char "0")
                (char "xX")
                (plus (alt (range 48 57) (range 97 102) (range 65 70))))))

  (string' (string 0)
    (concat (char "\"")
            (star (alt (except "\\\"")
                      (concat (char "\\") (char "\\\"abfnrtv"))))
            (char "\"")))

  (_ (op_left_paren 0) (word "("))
  (_ (op_right_paren 0) (word ")"))
  (_ (op_left_bracket 0) (word "["))
  (_ (op_right_bracket 0) (word "]"))
  (_ (op_period 0) (word "."))
  (_ (op_quote 0) (word "`"))
  (_ (op_comma 0) (word ","))
  (_ (op_colon 0) (word ":"))
  (_ (op_semicolon 0) (word ";"))

  (_ (op_double_colon_equals 0) (word "::="))
  (_ (op_plus 0) (word "+"))
  (_ (op_minus 0) (word "-"))
  (_ (op_asterisk 0) (word "*"))
  (_ (op_slash 0) (word "/"))
  (_ (op_less_equals 0) (word "<="))
  (_ (op_less 0) (word "<"))
  (_ (op_greater_equals 0) (word ">="))
  (_ (op_greater 0) (word ">"))
  (_ (op_equals 0) (word "="))
  (_ (op_double_equals 0) (word "=="))
  (_ (op_bang_equals 0) (word "!="))
  (_ (op_bang 0) (word "!"))
  (_ (op_amp_amp 0) (word "&&"))
  (_ (op_bar_bar 0) (word "||"))
  (_ (op_left_arrow 0) (word "<-"))
  (_ (op_right_arrow 0) (word "->"))
  (_ (op_left_right_arrow 0) (word "<->"))
  (_ (op_double_right_arrow 0) (word "=>"))
  (_ (op_double_left_right_arrow 0) (word "<=>"))

  (_ (kw_let 0) (word "let"))
  (_ (kw_in 0) (word "in"))
  (_ (kw_fun 0) (word "fun"))
  (_ (kw_if 0) (word "if"))
  (_ (kw_then 0) (word "then"))
  (_ (kw_else 0) (word "else"))
  (_ (kw_match 0) (word "match"))
  (_ (kw_with 0) (word "with"))

))

(define rules `(

  // See: https://github.com/digama0/mm0/blob/master/mm0-hs/mm1.md#s-expressions

  (id' (tree 0) ((symbol 0)))
  (id' (tree 0) ((nat64 0)))
  (id' (tree 0) ((string 0)))

  (nil' (list 0) ())
  (cons' (list 0) ((tree 0) (list 0)))
  (period' (list 0) ((tree 0) (op_period 0) (tree 0)))
  (quote' (tree 0) ((op_quote 0) (tree 0)))
  (unquote' (tree 0) ((op_comma 0) (tree 0)))
  (tree' (tree 0) ((op_left_paren 0) (list 0) (op_right_paren 0)))
  (id' (_ 0) ((tree 0)))

  // Extended part

  (syncat_default' (syncat 0) ((op_less 0) (symbol 0) (op_greater 0)))
  (syncat_prec' (syncat 0) ((op_less 0) (symbol 0) (nat64 0) (op_greater 0)))
  (nil' (syncats 0) ())
  (cons' (syncats 0) ((syncat 0) (syncats 0)))
  (pattern' (tree 0) ((op_left_bracket 0) (symbol 0) (syncat 0) (op_double_colon_equals 0) (tree 0) (op_right_bracket 0)))
  (rule' (tree 0) ((op_left_bracket 0) (symbol 0) (syncat 0) (op_double_colon_equals 0) (syncats 0) (op_right_bracket 0)))

  (minus' (expr 90) ((op_minus 0) (expr 90)))
  (mul' (expr 80) ((expr 80) (op_asterisk 0) (expr 81)))
  (div' (expr 80) ((expr 80) (op_slash 0) (expr 81)))
  (add' (expr 70) ((expr 70) (op_plus 0) (expr 71)))
  (sub' (expr 70) ((expr 70) (op_minus 0) (expr 71)))
  (le' (expr 60) ((expr 61) (op_less_equals 0) (expr 61)))
  (lt' (expr 60) ((expr 61) (op_less 0) (expr 61)))
  (ge' (expr 60) ((expr 61) (op_greater_equals 0) (expr 61)))
  (gt' (expr 60) ((expr 61) (op_greater 0) (expr 61)))
  (eq' (expr 60) ((expr 61) (op_double_equals 0) (expr 61)))
  (neq' (expr 60) ((expr 61) (op_bang_equals 0) (expr 61)))
  (not' (expr 50) ((op_bang 0) (expr 50)))
  (and' (expr 43) ((expr 43) (op_amp_amp 0) (expr 44)))
  (or' (expr 42) ((expr 42) (op_bar_bar 0) (expr 43)))
  (implies' (expr 41) ((expr 41) (op_right_arrow 0) (expr 42)))
  (iff' (expr 40) ((expr 40) (op_left_right_arrow 0) (expr 41)))

  (_ (opt_comma 0) ())
  (_ (opt_comma 0) ((op_comma 0)))

  (binding' (binding 0) ((symbol 0) (op_equals 0) (expr 0) (opt_comma 0)))
  (nil' (bindings 0) ())
  (cons' (bindings 0) ((binding 0) (bindings 0)))
  (let' (expr 0) ((kw_let 0) (bindings 0) (kw_in 0) (expr 0)))
  (fun' (expr 0) ((kw_fun 0) (expr 0) (op_double_right_arrow 0) (expr 0)))
  (if' (expr 0) ((kw_if 0) (expr 0) (kw_then 0) (expr 0) (kw_else 0) (expr 0)))
  (clause' (clause 0) ((expr 0) (op_double_right_arrow 0) (expr 0) (opt_comma 0)))
  (nil' (clauses 0) ())
  (cons' (clauses 0) ((clause 0) (clauses 0)))
  (match' (expr 0) ((kw_match 0) (expr 0) (kw_with 0) (clauses 0)))

  (id' (expr 100) ((tree 0)))
  (tree' (tree 0) ((op_left_bracket 0) (expr 0) (op_right_bracket 0)))

))

// TEMP CODE
(define true (eq 1 1))
(define false (eq 1 2))

(define_macro syncat_default' (lambda (_ x _) `(,x 0)))
(define_macro syncat_prec' (lambda (_ l r _) `(,l ,r)))
(define_macro pattern' (lambda (_ m l _ r _) ``(,m ,l ,r)))
(define_macro rule' (lambda (_ m l _ r _) ``(,m ,l ,r)))

(define_macro minus' (lambda (_ x) `(minus ,x)))
(define_macro add' (lambda (l _ r) `(add ,l ,r)))
(define_macro sub' (lambda (l _ r) `(sub ,l ,r)))
(define_macro mul' (lambda (l _ r) `(mul ,l ,r)))
(define_macro div' (lambda (l _ r) `(div ,l ,r)))
(define_macro le' (lambda (l _ r) `(le ,l ,r)))
(define_macro lt' (lambda (l _ r) `(lt ,l ,r)))
(define_macro ge' (lambda (l _ r) `(ge ,l ,r)))
(define_macro gt' (lambda (l _ r) `(gt ,l ,r)))
(define_macro eq' (lambda (l _ r) `(eq ,l ,r)))
(define_macro neq' (lambda (l _ r) `(neq ,l ,r)))
(define_macro not' (lambda (_ x) `(not ,x)))
(define_macro and' (lambda (l _ r) `(and ,l ,r)))
(define_macro or' (lambda (l _ r) `(or ,l ,r)))
(define_macro implies' (lambda (l _ r) `(implies ,l ,r)))
(define_macro iff' (lambda (l _ r) `(iff ,l ,r)))

(define_macro binding' (lambda (sym _ val _) `(,sym ,val)))
(define_macro let' (lambda (_ bindings _ body) `(letrec ,bindings ,body)))
(define_macro fun' (lambda (_ arg _ body) `(lambda ,arg ,body)))
(define_macro if' (lambda (_ c _ t _ f) `(cond ,c ,t ,f)))
(define_macro clause' (lambda (pat _ val _) `(,pat ,val)))
(define_macro match' (lambda (_ e _ clauses) `(match ,e ,clauses)))

(set_syntax patterns rules)
